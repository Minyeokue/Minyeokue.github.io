---
title: 네트워크 공부 1
excerpt: "네트워크 기초에 대한 공부, 이후 시스코 패킷 트레이서를 통해 실습"
author: minyeokue
date: 2024-03-26 21:46:29 +0900
last_modified_at: 2024-03-27 22:02:25 +0900
categories: [Network Class]
tags: [Network]

toc: true
toc_sticky: true
---

<br>

네트워크 기초에 대해 복습하고, 개념을 이해하도록 노력한다. 이후 시스코 패킷 트레이서를 통해 실습해보면서 개념을 숙지하자.

<br>

---

# 네트워크

<br>

네트워크란 컴퓨터 관점에서 한 장비에서 다른 장비를 통신매체(Media)로 연결해서 정보나 자료를 전달하는 조직이나 망을 의미한다. 네트워크를 적용하면서 정보와 자료, 자원의 공유가 훨씬 편해졌다.

<br>

#### LAN (Local Area Network)

<br>

LAN은 근거리 통신망을 의미하며, 한정된 좁은 지역에 구성된 네트워크를 일반적으로 LAN이라고 한다.

현실에서 LAN의 예시로는 PC방, 사무실, 연구소, 강의실 등이 있다.

<br>

LAN의 특징으로는 초기 투자 비용이 높지만, 유지 보수비용은 낮다는 점이 있으며, 일반적으로 LAN의 관리는 사내 관리자가 맡게 된다.

LAN의 대표적인 장비로는 **Switch(Bridge)**, **Hub**가 있다.

<br>

#### WAN (Wide Area Network)

<br>

WAN은 원거리 통신망을 의미하며, 넓은 지역을 연결하는 네트워크를 WAN이라고 일컫는다. (ex. LAN과 LAN을 서로 연결하는 광역 네트워크)

<br>

WAN의 특징으로는 초기 투자 비용이 낮지만, 유지 보수비용이 LAN보다 높다는 점이 있다. 일반적으로 관리를 ISP(Internet Service Provider) 업체가 맡게 된다.

WAN의 대표적인 장비는 **Router**가 있다.

<br>

*인터넷*은 전세계의 수많은 LAN과 WAN이 연결된 거대한 네트워크를 의미하며, 정보를 공유하기 위한 목적으로 구성된 통신망의 집합체이다.

언어와 문화가 다른 전 세계 사람들이 통신하기 위해, 연결된 네트워크 간에 서로 동일한 **프로토콜(Protocol)**을 사용해야할 필요가 생겼다.

<br>

---

<br>

## 프로토콜(Protocol)

<br>

1) 일반적 정의

네트워크 내의 컴퓨터들이 통신을 효율적으로 하기 위한 여러가지 규칙을 뜻한다.

2) 기술적 정의

규칙들 또는 상호 합의된 것들의 모임으로, 데이터의 형식(포맷)과 전송에 대한 것들을 정의하는 것을 뜻한다.

<br>

프로토콜(Protocol)은 연결된 네트워크 간에 서로 통신을 하기 위한 **통신 규약**, 서로 간의 약속, 표준 규격이라고 할 수 있다.

<br>

---

#### 통신 방식에 따른 네트워크 분류

<br>

##### 1. 유니캐스트 (Unicast)

<br>

유니캐스트는 1 대 1 전달 방식으로, 수신측이 한 곳으로 정해져 있는 경우를 말한다.

IP 주소를 전세계의 하나 뿐인 수신측의 랜카드 MAC(Media Access Control) 주소를 **ARP**라는 프로토콜을 통해 알아내서 통신을 진행한다.

<br>

##### 2. 브로드캐스트 (Broadcast)

<br>

브로드캐스트는 1 대 전체 전달 방식으로, 불특정 다수에게 전부 전송하는 경우를 말한다.

<br>

동일 네트워크에 연결된 모든 네트워크 장비에게 보내는 통신이다. 즉, Broadcast domain 안의 모든 장비들에게 전송하는 것이며, 예시로는 TV, Radio 등이 있다.

> 브로드캐스트(Broadcast)의 단점으로는 해당 네트워크 안의 시스템 CPU에게 부하를 주게 된다. 일반적으로 CPU가 일을 처리할 때 하던 일을 멈추고 브로드캐스트에게 전송받은 요청을 먼저 처리하기 때문인데, 이를 **Interrupt**라고 한다. 따라서 한 네트워크의 범위를 너무 넓게 구성하는 것은 바람직하지 않다.
{: .prompt-warning }

<br>

##### 3. 멀티캐스트 (Multicast)

<br>

멀티캐스트는 1 대 그룹 전달 방식으로, 정해진 특정 그룹에게 전송하는 경우를 말한다. 쉬운 예시로는 케이블 TV, 인터넷 방송등이 있다.

<br>

---

<br>

### 네트워크의 주소

<br>

+ MAC Address : 물리적 주소

  + ex. 00-19-D1-F0-09-FF => 윈도우 표현식
        00:19:D1:F0:09:FF => 리눅스 표현식
        0019.D1F0.09FF

+ IP Address : 논리적 주소

  + ex. 192.1168.21.1

<br>

각 장비들은 정확한 통신을 위해 네트워크 상에서 서로 구분해야 하는데, 이 역할을 하는 것이 바로 MAC(Media Access Control) Address이다.

<br>

TCP/IP 프로토콜이라는 전세계 표준 프로토콜을 통해 네트워크(인터넷)에서 IP Address를 서로의 위치를 알 수 있지만, 그렇게 통신하더라도 최종적으로는 MAC Address를 사용하여 데이터를 전송한다.

네트워크 장비의 인터페이스는 고유의 MAC Address를 가지고 있다.

<br>

#### MAC 주소의 표현 방법

<br>

네트워크에 연결된 장비들이 가지는 48bit(6 Octet)의 고유한 MAC 주소는 전세계에서 유일하며 **Physical Address**, 물리적 주소라고도 한다.

<br>

2진수로 48bit인 주소이지만, 16진수로 표현해 4자리씩 끊어서 16진수화 시킨다. -> 16진수 12자리로 MAC Address를 표현한다.

<br>

-> ex. 0000 0000.0110 0000.1001 0111.1000 1111.0100 1111.1000 0110

   => 00-60-97-8F-4F-86
      00:60:97:8F-4F:86
      0060.978F.4F86

<br>

48bit 중 절반으로 나눈 앞의 24bit(6자리 16진수)는 생산자(생산 회사)를 나타내는 코드로 OUI(Organizational Unique Identifier)라고 한다. 그 이후에 오는 24bit는 해당 장비를 만든 회사에서 각 장비에 분배하는 Host Identifier. 즉, 시리얼 넘버이다.

<br>

#### ARP (Address Resolution Protocol)

<br>

일반적으로 IP 주소만을 보기 때문에, IP 주소로만 통신한다고 생각하기 쉽지만, IP 주소와 MAC 주소를 서로 매핑시켜주는 절차를 거쳐 통신이 이루어지며, 해당 절차를 **ARP**라고 한다.

![ARP 동작 절차](/assets/img/2024-03-26/1.png)
_ARP 동작 절차_

<br>

### IP 주소

<br>

TCP/IP 프로토콜을 사용하는 장비들을 구분해주기 위해 만든 것이 바로 IP Address이며 표현 방법에는 **IPv6**와 **IPv4**가 있다.

오늘은 IPv4를 주로 이야기 하도록 하겠다.

<br>

+ IPv4

  + 32bit로 구성

  + 8bit 씩 나눠서 4개의 Octet으로 구분 (-> 8bit.8bit.8bit.8bit )

    + ex. 1100 0000.1010 1000.0000 1100.0000 0001 --> 192.168.12.1

<br>

![IPv4 옥텟 설명](/assets/img/2024-03-26/2.png)
_IPv4 옥텟 설명_

<br>

IP Address는 논리적인 주소이며, TCP/IP를 사용하는 네트워크 상에 연결된 장비들에게 고유의 IP 주소가 부여된다.

  -> 주소가 같은 다른 장비가 존재해서 IP 주소의 충돌이 발생하면 통신이 불가능하게 된다.

<br>

IP Address는 네트워크 부분과 호스트 부분으로 구성된다.

  -> IP Address = Network ID + Host ID

<br>

IP 주소에 대한 설명을 이어나가기 전에 같은 네트워크(하나의 네트워크)에 대한 설명을 해야한다.

<br>

하나의 네트워크란 하나의 **Broadcast Domain**이며, L3 장비(Router)를 거치지 않고 통신이 가능한 영역을 말한다.

같은 네트워크는 Network ID는 모두 같고, Host ID 부분이 모두 달라야 하며, 이렇게 IP 주소를 Network 부분과 Host 부분으로 구분해주는 역할을 하는 것이 **Subnet Mask**이다.

<br>

### 서브넷 마스크 (Subnet Mask)

<br>

위에서 설명한 Subnet Mask는 IP 주소를 Network 부분과 Host 부분으로 구분하는 역할을 한다.

  -> IP Address = Network ID (고정된 bit) + Host ID (고정되지 않은 bit)

<br>

IP 주소와 서브넷 마스크를 AND 연산하면 Network ID 값을 구할 수 있으며, 네트워크를 할당받으면 Host 부분은 사용자 마음대로 사용할 수 있다.

<br>

![서브넷마스크 예시](/assets/img/2024-03-26/3.png)
_서브넷마스크 예시_

<br>

위 사진에서 얻은 Network ID의 Host 부분은 전부 0이 되며, Host 부분을 전부 0으로 채운 것이 *Network ID*, Host 부분을 전부 1로 채운 것이 *Broadcast 주소*이다.

<br>

Network ID와 브로드캐스트 주소는 IP 주소로 활용할 수 없으며, 위의 사진에서 해당 Network에서 분배할 수 있는 IP 범위는 172.16.0.1 ~ 172.16.255.254로 2^16 - 2(65,536 - 2), 총 65,534개의 장비가 네트워크를 이용할 수 있게된다.

65,534의 범위 안에 존재하는 **게이트웨이**에게 할당하기 위해 1자리를 또 뺀다면, 서브네팅이 존재하지 않다면 일반 사용자는 65,533명이 존재할 수 있다.

<br>

**게이트웨이**는 *다른 해당 네트워크에서 다른 네트워크로 향하는 통로*이며, 라우터와 함께 존재하는 경우가 많다.

<br>

#### 서브네팅

<br>

+ "192.168.10.0/24 네트워크를 4개의 서브넷으로 구성하라" 라고 한다면

1100 0000.1010 1000.0000 1010.0000 0000에서 1100 0000.1010 1000.0000 1010.**0000 0000** 강조된 부분의 맨 앞에서부터 필요한 만큼 2^N의 결과로 가장 가까운 값을 선택한다. (필요한 네트워크보다 모자르면 안된다.)

그렇다면 2^N의 값이 4가 되는 값 N = 2이고, Host 주소에서 맨 앞 2자리를 네트워크 서브넷을 위해 사용한다.

<br>

"192.168.10.\|00\|000000" "\|"로 구분한 부분이 네트워크 서브넷을 위해 필요한 비트 수이며, '00', '01', '10', '11' 4가지의 경우의 수가 생긴다.

<br>

서브넷|네트워크 ID|브로드캐스트 주소|사용가능 범위
:---:|:---:|:---:|:---:
1 192.168.10.[00]XXXXXX|192.168.10.0|192.168.10.63|192.168.10.1 ~ 192.168.10.62
2 192.168.10.[01]XXXXXX|192.168.10.64|192.168.10.127|192.168.10.65 ~ 192.168.10.126
3 192.168.10.[10]XXXXXX|192.168.10.128|192.168.10.191|192.168.10.129 ~ 192.168.10.190
4 192.168.10.[11]XXXXXX|192.168.10.192|192.168.10.255|192.168.10.193 ~ 192.168.10.254

<br>

각 서브넷은 네트워크 ID로부터 브로드캐스트 주소의 차이가 63씩 차이나고, 다음 서브넷과 이전 브로드캐스트의 차이는 1씩 나게 된다.

이 차이는 "\|XX\|000000" 에서 뒤의 6개의 2진수 bit가 모두 1일 경우 63(1 + 2 + 4 + 8 + 16 + 32)이 되기 때문이다.

<br>

---

## 시스코 패킷트레이서 실습

<br>

- 시나리오

  - 스위치1 -> 라우터 게이트웨이 192.168.100.1

    - PC0 (192.168.100.10/24)

    - PC1 (192.168.100.20/24)
  
  - 스위치2 -> 라우터 게이트웨이 192.168.200.1

    - PC2 (192.168.200.10/24)

    - PC3 (192.168.200.20/24)

=> 서로 다른 네트워크를 가진 PC끼리 통신이 가능하도록 라우터를 설정하자.

<br>

![패킷 트레이서 기본 상태](/assets/img/2024-03-26/4.png)
_패킷 트레이서 기본 상태_

<br>

위와 같은 상태로 Generic 스위치 2개에 각각 Generic PC 2대씩 연결해놓았다. 이제 각 PC마다 IP를 설정해보겠다.

![PC IP 설정 버튼](/assets/img/2024-03-26/5.png)
_PC IP 설정 버튼_

![PC IP 설정](/assets/img/2024-03-26/6.png)
_PC IP 설정_

<br>

위와 같은 설정을 다른 3대의 PC에도 적용하도록 한다. 그 이후 터미널을 통해 다른 PC와 통신이 가능한지 확인해보겠다.

<br>

설정이 완료된 후 이제 터미널(CMD)를 통해 같은 네트워크에 있는 PC(192.168.100.20)와 통신이 되는지 확인한다.

![PC 터미널 버튼](/assets/img/2024-03-26/7.png)
_PC 터미널 버튼_

![LAN 통신](/assets/img/2024-03-26/8.png)
_LAN 통신_

<br>

192.168.100 대역에 있는 PC끼리는 통신이 원활하게 되는 것을 확인했다. 스위치 2와 연결된 PC는 네트워크가 다르기 때문에 통신할 수 없을 것이다.

![네트워크와 통신 불가](/assets/img/2024-03-26/9.png)
_네트워크와 통신 불가_

<br>

사실 다른 네트워크와 통신할 수 있도록 라우터가 연결되어 있지도 않고, 게이트웨이에 해당하는 장비를 연결하지도 않아서 통신 연결이 닿지 않은 것이 당연한 결과이다.

<br>

이제 다른 네트워크에서도 통신이 가능하도록 라우터를 연결해보겠다.

![라우터 배치](/assets/img/2024-03-26/10.png)
_라우터 배치_

<br>

라우터를 배치하고 각 스위치에 연결했다. 192.168.100.0 네트워크 스위치는 라우터의 fa0/0에 연결되었고, 192.168.200.0 네트워크 스위치는 라우터의 fa1/0에 연결되었다.

> fa0/0과 fa1/0의 fa는 FastEthernet의 약자로, FastEthernet은 100Mbps의 속도를 가진다.
{: .prompt-tip }

fa0/0은 게이트웨이 192.168.100.1로 설정하고, fa1/0은 게이트웨이 192.168.200.1으로 설정하겠다.

<br>

fa0/0과 fa1/0에는 현재 열려있지 않다는 뜻으로 붉은 빛이 켜져있는 상태이다. 라우터를 클릭해 명령어를 입력해 각각의 네트워크 게이트웨이로 사용하겠다.

![라우터 터미널 버튼](/assets/img/2024-03-26/11.png)
_라우터 터미널 버튼_

![라우터 게이트웨이 설정](/assets/img/2024-03-26/12.png)
_라우터 게이트웨이 설정_

<br>

```cli
         --- System Configuration Dialog ---

Continue with configuration dialog? [yes/no]: no


Press RETURN to get started!



Router>enable
Router#configure terminal
Enter configuration commands, one per line.  End with CNTL/Z.
Router(config)#interface fa0/0
Router(config-if)#ip addr 192.168.100.1 255.255.255.0
Router(config-if)#no shutdown

Router(config-if)#
%LINK-5-CHANGED: Interface FastEthernet0/0, changed state to up

%LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/0, changed state to up

```

> `enable` -> `en`, `configure terminal` -> `conf t`, `interface fa0/0` -> `int fa0/0`, `no shutdown` -> `no sh`로 축약(단축 명령어)할 수 있다.
{: .prompt-tip}

<br>

![라우터 게이트웨이 설정 완료1](/assets/img/2024-03-26/13.png)
_라우터 게이트웨이 설정 완료1_

<br>

위의 명령어처럼 IP 주소를 설정하고 `no shutdown`을 입력하면, 아래 사진처럼 연결이 활성화되었다고 초록빛으로 변경된다.

<br>

같은 방식으로 fa1/0도 192.168.200.1로 설정해준다.

```cli
Router(config-if)#exit
Router(config)#int fa1/0
Router(config-if)#ip addr 192.168.200.1 255.255.255.0
Router(config-if)#no sh

Router(config-if)#
%LINK-5-CHANGED: Interface FastEthernet1/0, changed state to up

%LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet1/0, changed state to up

```

<br>

![라우터 게이트웨이 설정 완료2](/assets/img/2024-03-26/14.png)
_라우터 게이트웨이 설정 완료2_

<br>

모든 설정이 완료되었다. 이제 192.168.100.10또는 192.168.100.20에서 192.168.200.0 네트워크에 접근이 가능하다. 또한 그 역방향도 성립한다. 테스트해보자.

<br>

![다른 네트워크 통신 성공](/assets/img/2024-03-26/15.png)
_다른 네트워크 통신 성공_

<br>

시나리오에 입력했던 대로 다른 네트워크와의 통신에 성공했다. 이제 `arp -a` 명령어를 입력해 IP 주소를 MAC 주소로 대응시킨 테이블을 확인해보도록 하겠다.

![게이트웨이와 같은 네트워크 MAC 주소](/assets/img/2024-03-26/16.png)
_게이트웨이와 같은 네트워크 MAC 주소_

<br>

이번 통신의 전체적인 과정을 설명하겠다.

<br>

1) 192.168.100.10와 다른 네트워크인 것을 AND 연산을 통해 알아낸다.

2) 다른 네트워크로 나가기 위해 192.168.100.255(브로드캐스트 주소)를 통해 192.168.100의 네트워크 ID를 가진 모든 시스템에게 게이트웨이가 있는지 질의한다.

3) 192.168.100.1이 자신이 게이트웨이라고 응답한다.

4) ARP 프로토콜을 통해 IP -> MAC 주소를 매핑하고 테이블에 저장한다.

5) 해당 게이트웨이 -> 라우터에게 192.168.200.0 네트워크를 찾는다.

6) 물리적으로 직접 연결된 라우터는 192.168.100.0과 192.168.200.0 모두를 알고 있기 때문에 192.168.200.0 네트워크의 게이트웨이인 192.168.200.1로 연결시킨다.

7) 해당 게이트웨이로 들어가 192.168.200.10을 찾고, 통신 요청을 받은 192.168.200.10은 요청에 대한 응답을 192.168.200.1에 보낸다.

8) 해당 응답은 라우터 -> 192.168.100.1 게이트웨이로 들어가 요청을 보냈던 PC에 전달한다.

<br>

중간에 생략된 부분도 존재하지만 대략적인 과정은 이렇다. 단순한 요청임에도 보기보다 많은 과정을 거치게 된다.

<br>

![라우터 라우팅 테이블 확인](/assets/img/2024-03-26/17.png)
_라우터 라우팅 테이블 확인_

<br>

위 사진처럼 관리자 상태에서 `show ip route` 명령을 통해 현재 라우터에 등록된 라우팅 테이블을 확인할 수 있다.